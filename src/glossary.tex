\newglossaryentry{algebraic data type}
{
  name={algebraic data type},
  description={\todo{define}}
}

\newglossaryentry{computation rule}
{
  name={computation rule},
  description={\todo{define}}
}

\newglossaryentry{dependent pattern matching}
{
  name={dependent pattern matching},
  description={\todo{define}}
}


\newglossaryentry{dependent type}
{
  name={dependent type},
  description={\todo{define}}
}

\newglossaryentry{elaboration reflection}
{
  name={elaboration reflection},
  description={\todo{define}}
}

\newglossaryentry{expression}
{
  name={expression},
  description={\todo{define}}
}

\newglossaryentry{extreme programming}
{
  name={extreme programming},
  description={\todo{define}}
}

\newglossaryentry{first-class}
{
  name={first-class},
  description={\todo{define}}
}

\newglossaryentry{fully certified}
{
  name={fully certified},
  description={\todo{define}}
}

\newglossaryentry{function type}
{
  name={function type},
  description={\todo{define}}
}

\newglossaryentry{functional programming}
{
  name={functional programming},
  description={\todo{define}}
}


\longnewglossaryentry{idris-add-clause}{
  name=\el{idris-add-clause},
  sort={idris-add-clause}
}
{
  \el{(idris-add-clause PROOF)}

  Add clauses to the declaration at point.
}

\longnewglossaryentry{idris-case-split}{
  name=\el{idris-case-split},
  sort={idris-case-split}
}
{
  \el{(idris-case-split)}

  Case split the pattern variable at point.
}

\longnewglossaryentry{idris-load-file}{
  name=\el{idris-load-file},
  sort={idris-load-file}
}
{
  \el{(idris-load-file &optional SET-LINE)}

  Pass the current bufferâ€™s file to the inferior Idris process.

  A prefix argument restricts loading to the current line.
}

\longnewglossaryentry{idris-proof-search}{
  name=\el{idris-proof-search},
  sort={idris-proof-search}
}
{
  \el{(idris-proof-search &optional ARG)}

  Invoke the proof search. A plain prefix argument causes the
  command to prompt for hints and recursion depth, while a numeric
  prefix argument sets the recursion depth directly.
}

\newglossaryentry{imperative}
{
  name={imperative},
  description={\todo{define}}
}

\newglossaryentry{induction}
{
  name={induction},
  description={\todo{define}}
}

\newglossaryentry{inductive proof}
{
  name={inductive proof},
  description={\todo{define}}
}

\newglossaryentry{inductive rule}
{
  name={inductive rule},
  description={\todo{define}}
}

\newglossaryentry{logic}
{
  name={logic},
  description={\todo{define}}
}

\newglossaryentry{module system}
{
  name={module system},
  description={\todo{define}}
}

\newglossaryentry{pattern matching}
{
  name={pattern matching},
  description={\todo{define}}
}

\newglossaryentry{polymorphic type system}
{
  name={polymorphic type system},
  description={\todo{define}}
}

\newglossaryentry{proof}
{
  name={proof},
  description={unassailable arguments for the truth of a particular
  proposition},
  descriptionplural={unassailable arguments for the truth of particular
  propositions},
  firstplural={\glsentryplural{proof} -- \glsentrydescplural{proof}}
}

\newglossaryentry{pub-sub}
{
  name={publish-subscribe},
  description={\todo{define}}
}

\newglossaryentry{pure}
{
  name={pure},
  description={\todo{define}}
}

\newglossaryentry{side effect}
{
  name={side effect},
  description={\todo{define}}
}

\newglossaryentry{structural recursion}
{
  name={structural recursion},
  description={\todo{define}}
}

\newglossaryentry{syntax}
{
  name=\idr{syntax},
  description={\todo{define}},
  sort={syntax}
}

\newglossaryentry{tactic}
{
  name={tactic},
  description={\todo{define}}
}

\newglossaryentry{type}
{
  name={type},
  description={\todo{define}}
}

\newglossaryentry{type system}
{
  name={type system},
  description={\todo{define}}
}

\newglossaryentry{value}
{
  name={value},
  description={\todo{define}}
}

\newglossaryentry{wildcard pattern}
{
  name={wildcard pattern},
  description={\todo{define}}
}




\newglossaryentry{proof assistant}{
  name={proof assistant},
  description={\todo{define}},
  see=[see also]{proof}
}

\newglossaryentry{automated theorem prover}
{
  name={automated theorem prover},
  description={\todo{define}},
  see=[see also]{proof assistant}
}




\newacronym{aop}{AOP}{aspect-oriented programming}

\newacronym{oop}{OOP}{object-oriented programming}

\newacronym{mvc}{MVC}{model-view-controller}

\newacronym{sat}{SAT}{Boolean (or propositional) satisfiability}

\newacronym{smt}{SMT}{satisfiability modulo theories}
